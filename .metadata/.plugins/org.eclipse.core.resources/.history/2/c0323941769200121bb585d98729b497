// package
package itt.t00154755.mouseserver;

// imports
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import javax.bluetooth.BluetoothStateException;
import javax.bluetooth.DiscoveryAgent;
import javax.bluetooth.LocalDevice;
import javax.bluetooth.RemoteDevice;
import javax.bluetooth.UUID;
import javax.microedition.io.Connector;
import javax.microedition.io.StreamConnection;
import javax.microedition.io.StreamConnectionNotifier;

/**
 * 
 * @author Christopher Donovan
 *         <p>
 *         This class creates a stream connection using the Bluecove API. The
 *         stream listens for a RFComm client once a client is found the stream
 *         connection is closed, to ensure that only one client is connected.
 *         <p>
 *         {@link http://docs.oracle.com/javase/tutorial/networking/index.html}
 *         <p>
 *         {@link http
 *         ://docs.oracle.com/javase/tutorial/essential/exceptions/index.html}
 * 
 */
public class AppServer extends Thread 
{
	private final ServerCommsThread serverThread;
	// string name of class
	private final String TAG = "App Server";
	private final UUID SPP_UUID = new UUID("27012f0c68af4fbf8dbe6bbaf7aa432a", false);
	// the connection string
	private final String connString = "btspp://localhost:" + SPP_UUID
			+ ";name=Java Server for Mouse App";

	/**
	 * AppServer constructor initializes a new server once it is calls.
	 * 
	 */
	public AppServer()
	{
		
	}// end of constructor

	/**
	 * Override the run method from the Thread Class.
	 * 
	 */
	@Override
	public void run()
	{
		
		LocalDevice pcDevice;
		try
		{
			pcDevice = LocalDevice.getLocalDevice();
		} 
		catch (BluetoothStateException e) 
		{
			e.printStackTrace();
		}	// create a new Stream Connection Notifier
		StreamConnectionNotifier connectionNotifier = null;

		// register the notifier
		try 
		{
			sUtils.info("open the connector");
			connectionNotifier = (StreamConnectionNotifier) Connector
					.open(connString);
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// display the details of the connected host device
		String hostDetails = "\nServer running on:\n" + "PC Address: "
				+ pcDevice.getBluetoothAddress() + "\n" + "PC Name: "
				+ pcDevice.getFriendlyName() + "\n";

		sUtils.info(hostDetails);

		try 
		{
			sUtils.info("make discovery");
			pcDevice.setDiscoverable(DiscoveryAgent.GIAC);
		} 
		catch (BluetoothStateException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// create a new Stream Connection
		StreamConnection streamConnection = null;

		// register the connection
		try 
		{
			sUtils.info("accept and open");
			streamConnection = connectionNotifier.acceptAndOpen();
		}
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// display the connected phone
		RemoteDevice androidPhone = null;

		try 
		{
			sUtils.info("remote device");
			androidPhone = RemoteDevice.getRemoteDevice(streamConnection);
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		sUtils.info("Remote device address: "
				+ androidPhone.getBluetoothAddress());

		try
		{
			sUtils.info("Remote device name: " + androidPhone.getFriendlyName(false));
		} 
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// create a new InputStream
		InputStream dataIn = null;

		// register the InputStream
		try 
		{
			dataIn = new DataInputStream(streamConnection.openInputStream());
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		
	}// end of the run method
	
	private class ServerCommsThread extends Thread 
	{
		// class variables
		private static final String TAG = "Server Communication Thread";
		private ServerUtils sUtils = new ServerUtils();
		private InputStream dataIn;
		private CursorRobot cRobot;

		/**
		 * 
		 * AppServer constructor initializes a new server once it is calls.
		 * 
		 * @param dataIn 
		 * 		the InputStream that was opened in the Server Class.
		 * 
		 */
		public ServerCommsThread(InputStream dataIn) 
		{
			sUtils.info( TAG );
			this.dataIn = dataIn;
		}
		
		/**
		 * 
		 * Override the run method of the Thread Class.
		 */
		@Override
		public void run() 
		{
			String acceloData;
			// create a new byte array
			byte[] buffer = new byte[1024];
			int bytes;
			
			// create a sort of infinite loop that runs
			// while the program is running
			while(true) 
			{
				try 
				{
					System.out.println(TAG + " Begin reading the bytes into the String");
					// read in the bytes
					while ((bytes = dataIn.read(buffer)) > 0) 
					{
						acceloData = (new String(buffer, 0, bytes));
						
						cRobot.sendToRobot(acceloData);
						System.out.println(TAG + " Send the String to the Robot");
						
					}
				} 
				catch (IOException ioe)
				{
					// print the error stack
					sUtils.error( TAG, ioe, 1 );
					// exit the program
					System.exit(-1);
				}
			}// end of the while loop
		}// end of run methods
	}// end of Class
	
}// end of Class
