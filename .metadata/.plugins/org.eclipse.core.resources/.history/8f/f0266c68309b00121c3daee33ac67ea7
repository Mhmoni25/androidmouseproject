// package

package itt.t00154755.mouseapp;

// imports
import java.io.IOException;
import java.util.UUID;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

/**
 * 
 * @author Christopher Donovan {@link http
 *         ://mobisocial.stanford.edu/news/2011/03/bluetooth-across-android
 *         -and-a-desktop/} {@link http
 *         ://developer.android.com/guide/topics/connectivity
 *         /bluetooth.html#EnablingDiscoverability}
 */
public class AppClient
{

	private static final String TAG = "App Client";

	private final UUID uuid = UUID.fromString("04c603b0-0001-0008-0000-0805f9b34fb");

	// bluetooth adapter Object
	private final BluetoothAdapter btAdapter;
	private final Handler appHandler;
	private ConnectThread connectThread;
	private ConnectedThread connectedThread;
	private int state;
	
	// used to check if the device is available
	private static final int NONE = 0;
	private static final int LISTEN = 1;
	private static final int CONNECTING = 2;
	private static final int CONNECTED = 3;

	// String value
	public String acceloData;

	// bluetooth socket
	private BluetoothSocket socket;

	// used to count the number of null packets being sent
	public int nullPacketsOut;

	/**
	 * 
	 */
	public AppClient(Context context, Handler handler)
	{
		btAdapter = BluetoothAdapter.getDefaultAdapter();
		state = NONE;
		
		appHandler = handler;
	}
	
	private synchronized void setState(int state)
	{
		this.state = state;
	}
	
	private synchronized int getState()
	{
		return state;
	}
	
	private synchronized void start()
	{
		if (connectThread != null)
		{
			connectThread.cancel();
			connectThread = null;
		}
		
		if (connectedThread != null)
		{
			connectedThread.cancel();
			connectThread = null;
		}
		
		setState(LISTEN);
	}
	
	public synchronized void connect(BluetoothDevice device)
	{
		if (state == CONNECTING)
		{
			if (connectThread != null)
			{
				connectThread.cancel();
				connectThread = null;
			}
		}
		
		if (connectedThread != null)
		{
			connectedThread.cancel();
			connectThread = null;
		}
		
		connectThread = new ConnectThread(device);
		connectThread.start();
		setState(CONNECTING);
	}
	
	public synchronized void connected(BluetoothSocket socket, BluetoothDevice device)
	{

		if (connectThread != null)
		{
			connectThread.cancel();
			connectThread = null;
		}
		
		if (connectedThread != null)
		{
			connectedThread.cancel();
			connectThread = null;
		}
		
		connectedThread = new ConnectedThread(socket);
		connectedThread.start();
		
		Message message = appHandler.obtainMessage(App.MESSAGE_DEVICE_NAME);
		Bundle bundle = new Bundle();
		bundle.putString(App.DEVICE_NAME, device.getName());
		message.setData(bundle);
		appHandler.sendMessage(message);
		
		setState(CONNECTED);
	}
	
	public synchronized void stop()
	{
		if (connectThread != null)
		{
			connectThread.cancel();
			connectThread = null;
		}
		
		if (connectedThread != null)
		{
			connectedThread.cancel();
			connectThread = null;
		}
		
		setState(NONE);
	}
	
	public void write(byte[] out)
	{
		ConnectedThread ct;
		
		synchronized(this)
		{
			if (state != CONNECTED)
				return;
			
				ct = connectedThread;
		}
		
		ct.write(out);
	}
	
	public void write(int out)
	{
		ConnectedThread ct;
		
		synchronized(this)
		{
			if (state != CONNECTED)
				return;
			
				ct = connectedThread;
		}
		
		ct.write(out);
	}
	
	
	private void connectionLost()
	{
		setState(LISTEN);
		
		Message message = appHandler.obtainMessage(App.MESSAGE_TOAST);
		Bundle bundle = new Bundle();
		bundle.putString(App.TOAST, "unable to connect to the server");
		message.setData(bundle);
		appHandler.sendMessage(message);
	}
	private void connectionFailed()
	{
		setState(LISTEN);
		
		Message message = appHandler.obtainMessage(App.MESSAGE_TOAST);
		Bundle bundle = new Bundle();
		bundle.putString(App.TOAST, "the connection was lost");
		message.setData(bundle);
		appHandler.sendMessage(message);
	}
	

	private class ConnectThread extends Thread
	{
		private final BluetoothDevice device;
		private final BluetoothSocket socket;
		
		public ConnectThread ( BluetoothDevice device )
		{
			this.device = device;
			 BluetoothSocket temp = null;
			try
			{
				//Log.d(TAG, "getting local device");
				// remote MAC here:
				//device = btAdapter.getRemoteDevice("00:15:83:3D:0A:57");
				Log.d(TAG, "connecting to service");
				temp = device.createRfcommSocketToServiceRecord(uuid);
			}
			catch ( Exception e )
			{
				Log.e(TAG, "Error connecting to device", e);
			}
			socket = temp;
		}
		
		
		public void run()
		{
			Log.d(TAG, "about to connect");

			btAdapter.cancelDiscovery();
			try
			{
				socket.connect();
			}
			catch ( IOException e )
			{
				connectionFailed();
				try
				{
					socket.close();
				}
				catch ( IOException e1 )
				{
					Log.e(TAG, "Error closing the socket connect thread", e1);
				}
				AppClient.this.start();
				return;
			}
			Log.d(TAG, "Connected!");
			
			synchronized(AppClient.this)
			{
				connectThread = null;
			}
			
			connected(socket, device);
		}
		
		

		public void cancel()
		{

			try
			{
				socket.close();
			}
			catch ( IOException e )
			{
				Log.e(TAG, "Error closing the socket close() connect thread", e);
			}
			
		}
		
	}
	
	private class ConnectedThread extends Thread
	{

		public ConnectedThread ( BluetoothSocket socket )
		{

			// TODO Auto-generated constructor stub
		}

		public void write( int out )
		{

			// TODO Auto-generated method stub
			
		}

		public void write( byte[] out )
		{

			// TODO Auto-generated method stub
			
		}

		public void cancel()
		{

			// TODO Auto-generated method stub
			
		}
		
	}

}// end of the class