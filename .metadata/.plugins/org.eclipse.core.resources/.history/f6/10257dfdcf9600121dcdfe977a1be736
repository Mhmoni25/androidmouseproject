/**
 * 
 */
package itt.t00154755.mouseapp;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.AsyncTask;
import android.util.Log;

/**
 * @author Christopher
 *
 */
public class CalibrateThesholdTask extends AsyncTask<String, Void, String> implements SensorEventListener{
	
	// this is a reference to the class that calls this asynctask
	private CheckBTAvailability cba;
	/**
	 * 
	 */
	public CalibrateThesholdTask(CheckBTAvailability cba) {
		this.cba = cba;
	}

	@Override
	protected String doInBackground(String... params) {
		// TODO Auto-generated method stub
		return null;
	}

	private void registerListener() 
	{
		Log.d(TAG, "In AcceleratorUpdater reg listener");
		sm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);

		if (sm.getSensorList(Sensor.TYPE_ACCELEROMETER).size() != 0) 
		{
			s = sm.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);
			sm.registerListener(this, s, SensorManager.SENSOR_DELAY_NORMAL);
		}
	}
	@Override
	public void onAccuracyChanged(Sensor sensor, int accuracy) 
	{
		//
	}

	@Override
	public void onSensorChanged(SensorEvent event)
	{
		float x = calibrateX(event.values[0]);
		float y = calibrateY(event.values[1]);
		
		float threshold = x/y;
		
		setThreshold(threshold);
	}
	
	private float calibrateX( float x )
	{
		boolean calibrating = true;
		float calX = 0;
		int count = 0;
		
		while ( calibrating )
		{
			calX += x;
			count++;
			if ( count == 100 )
			{
				calibrating = false;
			}
		}
		
		calX = ( calX / count );

		return calX;
	}
	
	private float calibrateY( float y )
	{
		
		boolean calibrating = true;
		float calY = 0;
		int count = 0;
		
		while ( calibrating )
		{
			calY += y;
			count++;
			if ( count == 100 )
			{
				calibrating = false;
			}
		}
		
		calY = ( calY / count );
		
		return calY;
	}
	
	public void setThreshold(float threshold)
	{
		this.threshold = threshold;
	}
	public float getThreshold()
	{
		return threshold;
	}
	
	@Override
	public void run()
	{
		
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			// 
			e.printStackTrace();
		}
		if (startTimer != endTimer)
		{
			ctHandler.post(new Runnable()
			{
				@Override
				public void run() 
				{
					String thresholdString = String.valueOf(getThreshold());
					checkBTAvail.displayTheshold(thresholdString);
				}
			});
		}
		else
		{
			sm.unregisterListener(this);
		}
	}

}
