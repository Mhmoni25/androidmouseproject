// package
package itt.t00154755.mouseapp;
// imports
import java.io.IOException;
import java.util.UUID;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.util.Log;

/**
 * 
 * @author Christopher Donovan
 * <p>
 * {@link http://mobisocial.stanford.edu/news/2011/03/bluetooth-across-android-and-a-desktop/}
 * {@link http://developer.android.com/guide/topics/connectivity/bluetooth.html#EnablingDiscoverability}
 */
public class AppClient extends Thread{

	private static final String TAG = "Android Phone";
	final UUID SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
	BluetoothAdapter btAdapter;
	private String acceloData;

	public AppClient() 
	{
		btAdapter = BluetoothAdapter.getDefaultAdapter();
	}
	
	@Override
	public void run() 
	{
		try 
		{
			Log.d(TAG, "getting local device");
			// remote MAC here:
			BluetoothDevice device = btAdapter.getRemoteDevice("00:15:83:3D:0A:57");
			getAccelerometerDataString(acceloData);
			ConnectThread ct = new ConnectThread(device, acceloData);
			ct.start();
		} 
		catch (Exception e) 
		{
			Log.e(TAG, "Error connecting to device", e);
		}
	}

	public void getAccelerometerDataString(String acceloData) {
		this.acceloData = acceloData;
		
	}


	private class ConnectThread extends Thread {
	    private final BluetoothSocket btSocket;
	    private final BluetoothDevice btDevice;
	    private String acceloData;
	 
	    public ConnectThread(BluetoothDevice device, String acceloData) {
	        // Use a temporary object that is later assigned to mmSocket,
	        // because mmSocket is final
	        BluetoothSocket tmp = null;
	        btDevice = device;
	        this.acceloData = acceloData;
	 
	        // Get a BluetoothSocket to connect with the given BluetoothDevice
	        try {
	            // MY_UUID is the app's UUID string, also used by the server code
	            tmp = btDevice.createRfcommSocketToServiceRecord(SPP_UUID);
	        } catch (IOException e) { }
	        btSocket = tmp;
	    }
	 
	    public void run() {
	        // Cancel discovery because it will slow down the connection
	        btAdapter.cancelDiscovery();
	 
	        try {
	            // Connect the device through the socket. This will block
	            // until it succeeds or throws an exception
	            btSocket.connect();
	        } catch (IOException connectException) {
	            // Unable to connect; close the socket and get out
	            try {
	                btSocket.close();
	            } catch (IOException closeException) { 
	            	cancel();
	            }
	            return;
	        }
	 
	        // Do work to manage the connection (in a separate thread)
	        ClientCommsThread cct = new ClientCommsThread(btSocket, acceloData);
	        cct.start();
	    }
	 
	    /** Will cancel an in-progress connection, and close the socket */
	    public void cancel() {
	        try {
	            btSocket.close();
	        } catch (IOException e) { }
	    }
	}

	private class ClientCommsThread extends Thread 
	{
		private static final String TAG = "Client Comms Thread";
		private BluetoothSocket socket;
		private String acceloData;

		public ClientCommsThread(BluetoothSocket socket, String acceloData) 
		{
			System.out.println(TAG);
			this.socket = socket;
			this.acceloData = acceloData;
		}

		@Override
		public void run() 
		{
			try 
			{
				while (true) 
				{
					try 
					{
						socket.getOutputStream().write(acceloData.getBytes());
					} 
					catch (IOException e) 
					{
						System.err.println(e.getMessage());
					}
				}
			} 
			catch (Exception e) 
			{
				// print the error stack
				e.printStackTrace();
				e.getCause();

			} 
			finally 
			{
				try 
				{
					if (socket != null) 
					{
						socket.close();
					}

				} 
				catch (IOException e) 
				{
					e.printStackTrace();
				}
			}
		}
	}
}